"""
SQL Execution Tool

Safely executes SQL queries generated by agents with security validations.
"""

from typing import List, Dict, Any, Optional
from sqlalchemy import text
from sqlalchemy.orm import Session
from sqlalchemy.exc import SQLAlchemyError
import re
from utils.logger import get_logger

logger = get_logger(__name__)


class SQLExecutionTool:
    """Tool for safely executing SQL queries"""
    
    # Forbidden SQL keywords (for safety)
    FORBIDDEN_KEYWORDS = [
        'DELETE', 'UPDATE', 'INSERT', 'DROP', 'TRUNCATE', 
        'ALTER', 'CREATE', 'GRANT', 'REVOKE', 'EXEC',
        'EXECUTE', 'CALL', 'DECLARE', 'SET'
    ]
    
    # Required filters
    REQUIRED_FILTERS = ['workspace_id']
    
    def __init__(self, db: Session):
        """
        Initialize SQL execution tool
        
        Args:
            db: Database session
        """
        self.db = db
        logger.info("Initialized SQLExecutionTool")
    
    def validate_query(self, query: str) -> tuple[bool, Optional[str]]:
        """
        Validate SQL query for safety
        
        Args:
            query: SQL query to validate
            
        Returns:
            (is_valid, error_message)
        """
        logger.info("Validating SQL query")
        
        # Check for forbidden keywords
        query_upper = query.upper()
        for keyword in self.FORBIDDEN_KEYWORDS:
            if re.search(r'\b' + keyword + r'\b', query_upper):
                error_msg = f"Forbidden SQL keyword detected: {keyword}"
                logger.warning(error_msg)
                return False, error_msg
        
        # Check for required filters (workspace_id)
        if 'workspace_id' not in query.lower():
            error_msg = "Query must filter by workspace_id for security"
            logger.warning(error_msg)
            return False, error_msg
        
        # Check if query is SELECT only
        if not query_upper.strip().startswith('SELECT'):
            error_msg = "Only SELECT queries are allowed"
            logger.warning(error_msg)
            return False, error_msg
        
        logger.info("Query validation passed")
        return True, None
    
    def execute_query(
        self, 
        query: str, 
        parameters: Dict[str, Any],
        limit: Optional[int] = 100
    ) -> Dict[str, Any]:
        """
        Execute SQL query safely with validation
        
        Args:
            query: SQL query to execute
            parameters: Query parameters (must include workspace_id)
            limit: Maximum rows to return
            
        Returns:
            Query results with metadata
        """
        logger.info(f"Executing SQL query with params: {list(parameters.keys())}")
        
        try:
            # Validate parameters
            if 'workspace_id' not in parameters:
                error_msg = "workspace_id parameter is required"
                logger.error(error_msg)
                return {
                    'success': False,
                    'error': error_msg,
                    'rows': [],
                    'row_count': 0
                }
            
            # Validate query
            is_valid, error_msg = self.validate_query(query)
            if not is_valid:
                return {
                    'success': False,
                    'error': error_msg,
                    'rows': [],
                    'row_count': 0
                }
            
            # Add LIMIT if not present
            if 'LIMIT' not in query.upper() and limit:
                query = f"{query.rstrip(';')} LIMIT {limit}"
            
            # Execute query
            logger.info(f"Executing query: {query[:200]}...")
            result = self.db.execute(text(query), parameters)
            
            # Fetch results
            rows = []
            for row in result:
                rows.append(dict(row._mapping))
            
            row_count = len(rows)
            logger.info(f"Query executed successfully, returned {row_count} rows")
            
            return {
                'success': True,
                'rows': rows,
                'row_count': row_count,
                'columns': list(rows[0].keys()) if rows else [],
                'query': query,
                'parameters': parameters
            }
            
        except SQLAlchemyError as e:
            error_msg = f"Database error: {str(e)}"
            logger.error(error_msg)
            return {
                'success': False,
                'error': error_msg,
                'rows': [],
                'row_count': 0
            }
        except Exception as e:
            error_msg = f"Unexpected error: {str(e)}"
            logger.error(error_msg)
            return {
                'success': False,
                'error': error_msg,
                'rows': [],
                'row_count': 0
            }
    
    def execute_multiple_queries(
        self,
        queries: List[Dict[str, Any]],
        workspace_id: str
    ) -> List[Dict[str, Any]]:
        """
        Execute multiple SQL queries in sequence
        
        Args:
            queries: List of {query: str, parameters: dict, name: str}
            workspace_id: Workspace ID (added to all queries)
            
        Returns:
            List of query results
        """
        logger.info(f"Executing {len(queries)} queries")
        
        results = []
        for query_obj in queries:
            query = query_obj.get('query', '')
            parameters = query_obj.get('parameters', {})
            name = query_obj.get('name', 'unnamed_query')
            
            # Ensure workspace_id is in parameters
            parameters['workspace_id'] = workspace_id
            
            result = self.execute_query(query, parameters)
            result['query_name'] = name
            results.append(result)
        
        return results
    
    def format_results_as_text(self, result: Dict[str, Any]) -> str:
        """
        Format query results as readable text
        
        Args:
            result: Query result from execute_query
            
        Returns:
            Formatted text output
        """
        if not result['success']:
            return f"❌ Error: {result['error']}"
        
        rows = result['rows']
        if not rows:
            return "ℹ️ No results found"
        
        output = []
        output.append(f"✅ Found {result['row_count']} rows\n")
        
        # Format as table
        columns = result['columns']
        
        # Header
        header = " | ".join(columns)
        output.append(header)
        output.append("-" * len(header))
        
        # Rows (limit display to first 10)
        for i, row in enumerate(rows[:10]):
            row_str = " | ".join(str(row.get(col, '')) for col in columns)
            output.append(row_str)
        
        if len(rows) > 10:
            output.append(f"\n... and {len(rows) - 10} more rows")
        
        return "\n".join(output)
    
    def get_query_example(self, analysis_type: str) -> Optional[str]:
        """
        Get example SQL query for common analysis types
        
        Args:
            analysis_type: Type of analysis (overdue, blocked, distribution, etc.)
            
        Returns:
            Example SQL query
        """
        examples = {
            'overdue': """
                SELECT 
                    id, title, status, priority,
                    due_date,
                    EXTRACT(DAY FROM NOW() - due_date) as days_overdue,
                    user_id
                FROM tasks
                WHERE workspace_id = :workspace_id
                  AND due_date < NOW()
                  AND status != 'Done'
                ORDER BY priority DESC, days_overdue DESC
            """,
            
            'blocked': """
                SELECT 
                    t.id, t.title, t.priority, t.created_at,
                    EXTRACT(DAY FROM NOW() - t.updated_at) as days_since_update
                FROM tasks t
                WHERE t.workspace_id = :workspace_id
                  AND t.status = 'Blocked'
                ORDER BY days_since_update DESC
            """,
            
            'distribution': """
                SELECT 
                    status,
                    COUNT(*) as count,
                    ROUND(100.0 * COUNT(*) / SUM(COUNT(*)) OVER (), 2) as percentage
                FROM tasks
                WHERE workspace_id = :workspace_id
                GROUP BY status
                ORDER BY count DESC
            """,
            
            'user_workload': """
                SELECT 
                    user_id,
                    COUNT(*) as total_tasks,
                    SUM(CASE WHEN status = 'In_Progress' THEN 1 ELSE 0 END) as in_progress,
                    SUM(CASE WHEN due_date < NOW() AND status != 'Done' THEN 1 ELSE 0 END) as overdue
                FROM tasks
                WHERE workspace_id = :workspace_id
                GROUP BY user_id
                ORDER BY in_progress DESC
            """
        }
        
        return examples.get(analysis_type)
